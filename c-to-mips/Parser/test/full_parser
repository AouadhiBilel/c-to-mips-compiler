

/*
============== Incomplete parser implementation ==================

primary_expression : IDENTIFIER           { std::cout << $1 ;}
                   | FLOAT_NUMBER         { std::cout << $1 ;}
                   | STRINGLITERAL        
                   | '(' expression ')'
                   ;



expression : assignment_expression
           | expression ',' assignment_expression
           ; 

assignment_expression : conditional_expression
                      | unary_expression assignment_operator assignment_expression
                      ;

conditional_expression : logical_or_expression
                       | logical_or_expression '?' expression ':' conditional_expression
                       ;

logical_or_expression : logical_and_expression
                      | logical_or_expression OR_OPERATOR logical_and_expression
                      ;

logical_and_expression : inclusive_or_expression
                       | logical_and_expression AND_OPERATOR inclusive_or_expression
                       ;

inclusive_or_expression : exclusive_or_expression
                        | inclusive_or_expression '|' exclusive_or_expression
                        ;

exclusive_or_expression : and_expression
                        | exclusive_or_expression '^' and_expression
                        ;

and_expression : equality_expression
               | and_expression '&' equality_expression
               ;

equality_expression : relational_expression
                    | equality_expression EQ_OPERATOR relational_expression
                    | equality_expression NE_OPERATOR relational_expression
                    ;

relational_expression : shift_expression
                      | relational_expression '<' shift_expression
                      | relational_expression '>' shift_expression
                      | relational_expression LE_OPERATOR shift_expression
                      | relational_expression GE_OPERATOR shift_expression
                      ;

shift_expression : additive_expression
                 | shift_expression LEFT_OPERATOR additive_expression
                 | shift_expression RIGHT_OPERATOR additive_expression
                 ;

additive_expression : multiplicative_expression
                    | additive_expression '+' multiplicative_expression
                    | additive_expression '-' multiplicative_expression
                    ;

multiplicative_expression : cast_expression
                          | multiplicative_expression '*' cast_expression
                          | multiplicative_expression '/' cast_expression
                          | multiplicative_expression '%' cast_expression
                          ;

/* incomplete - INT only */

cast_expression : unary_expression
                | '(' type_name ')' cast_expression
                ;

assignment_operator : '='
                    | MUL_ASSIGNMENT
                    | DIV_ASSIGNMENT
                    | MOD_ASSIGNMENT
                    | ADD_ASSIGNMENT
                    | SUB_ASSIGNMENT
                    | LEFT_ASSIGNMENT
                    | RIGHT_ASSIGNMENT
                    | AND_ASSIGNMENT
                    | XOR_ASSIGNMENT
                    | OR_ASSIGNMENT
                    ;


/* incomplete - INT only */

unary_expression : postfix_expression
                 | INC_OPERATOR unary_expression
                 | DEC_OPERATOR unary_expression
                 | unary_operator cast_expression
                 | SIZEOF unary_expression
                 | SIZEOF '(' type_name ')'
                 ;

postfix_expression : primary_expression
                   | postfix_expression '[' expression ']'
                   | postfix_expression '(' ')'
                   | postfix_expression '(' argument_expression_list ')'
                   | postfix_expression '.' IDENTIFIER
                   | postfix_expression PTR_OPERATOR IDENTIFIER
                   | postfix_expression INC_OPERATOR
                   | postfix_expression DEC_OPERATOR
                   ;

argument_expression_list : assignment_expression
                         | argument_expression_list ',' assignment_expression
                         ;

unary_operator : '&'
               | '*'
               | '+'
               | '-'
               | '~'
               | '!'
               ;

type_name : INT

control_flow : IF '(' expression ')' statement
             | IF '(' expression ')' statement ELSE statement
             | WHILE '(' expression ')' statement
             | FOR '(' expression_statement expression_statement ')' statement
             | FOR '(' expression_statement expression_statement expression ')' statement
             ; 

statement : labeled_statement
          | compound_statement
          | expression_statement
          | selection_statement
          | iteration_statement
          | jump_statement
          ;

labeled_statement : IDENTIFIER ':' statement
                  | CASE constant_expression ':' statement
                  | DEFAULT ':' statement
                  ;

constant_expression : conditional_expression
                    ;

compound_statement : '{' '}'
                   | '{' {std::cout << "SCOPE" << std::endl } statement_list '}'
                   | '{' {std::cout << "SCOPE" << std::endl } declaration_list '}'
                   | '{' {std::cout << "SCOPE" << std::endl } declaration_list statement_list '}'
                   ;

statement_list : statement
               | statement_list statement
               ;

declaration_list : declaration
                 | declaration_list declaration
                 ;

declaration : declaration_specifiers ';'
            | declaration_specifiers init_declarator_list ';'
            ;

declaration_specifiers
  : storage_class_specifier
  | storage_class_specifier declaration_specifiers
  | type_specifier
  | type_specifier declaration_specifiers
  | type_qualifier
  | type_qualifier declaration_specifiers
  ;

storage_class_specifier
  : TYPEDEF
  | EXTERN
  | STATIC
  | AUTO
  | REGISTER
  ;

/* 

  | struct_or_union_specifier
  | enum_specifier

*/

type_specifier
  : VOID
  | CHAR
  | SHORT
  | INT
  | LONG
  | FLOAT
  | DOUBLE
  | SIGNED
  | UNSIGNED
  | type_name
  ;

type_qualifier
  : CONST
  | VOLATILE
  ;

init_declarator_list
  : init_declarator
  | init_declarator_list ',' init_declarator
  ;

init_declarator
  : declarator
  | declarator '=' initializer
  ;

declarator
  : pointer direct_declarator
  | direct_declarator
  ;

pointer : '*'
        | '*' type_qualifier_list
        | '*' pointer
        | '*' type_qualifier_list pointer
        ;

type_qualifier_list
  : type_qualifier
  | type_qualifier_list type_qualifier
  ;

direct_declarator : IDENTIFIER
                    | '(' declarator ')'
                    | direct_declarator '[' constant_expression ']'
                    | direct_declarator '[' ']'
                    | direct_declarator '(' parameter_type_list ')'
                    | direct_declarator '(' identifier_list ')'
                    | direct_declarator '(' ')'
                    ;

parameter_type_list
  : parameter_list
  | parameter_list ',' ELLIPSIS
  ;

parameter_list
  : parameter_declaration
  | parameter_list ',' parameter_declaration
  ;

/*   | declaration_specifiers abstract_declarator */

parameter_declaration
  : declaration_specifiers declarator
  | declaration_specifiers
  ;


identifier_list
  : IDENTIFIER
  | identifier_list ',' IDENTIFIER
  ;



initializer
  : assignment_expression
  | '{' initializer_list '}'
  | '{' initializer_list ',' '}'
  ;

initializer_list
  : initializer
  | initializer_list ',' initializer
  ;



expression_statement : ';'
                     | expression ';'
                     ;

selection_statement
  : IF '(' expression ')' statement
  | IF '(' expression ')' statement ELSE statement
  | SWITCH '(' expression ')' statement
  ;

iteration_statement
  : WHILE '(' expression ')' statement
  | DO statement WHILE '(' expression ')' ';'
  | FOR '(' expression_statement expression_statement ')' statement
  | FOR '(' expression_statement expression_statement expression ')' statement
  ;

jump_statement : GOTO IDENTIFIER ';'
               | CONTINUE ';'
               | BREAK ';'
               | RETURN ';'
               | RETURN expression ';'
               ;



*/

























/*

etc...................

values : INT IDENTIFIER                { std::cout << "    PARAMETER : " << $2 << std::endl; }
       | values COMMA INT IDENTIFIER   { std::cout << "    PARAMETER : " << $4 << std::endl; }
       ;


==================================== OLD

{
  function(int a,int b,int c){}
}


variable : INT IDENTIFIER   { std::cout << "VARIABLE : " << $2 << std::endl; };

bool scoping = false;

Scopes
{ scoping = true; std::cout << "SCOPE" << std::endl;}

 { scoping = false; }


// TODO : identation of 4 spaces
// TODO : Lexer is incomplete - code punctuators, both in regex and lexer cout << ....
VARIABLE : keyword identifier | keyword identifier EXTENSION* ;


EXTENSION : operator (identifier|num);

SCOPE_START : left curly ----- { cout << "SCOPE" << endl; }

SCOPE_END :


*/


